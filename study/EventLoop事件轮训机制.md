#### JS单线程（Event loop存在的背景）  
- 由于JavaScript是单线程语言的特性，所以 JS 同一时间只能做一件事情。
- 如果有很多任务就必须排队，等一个任务处理完才能处理下一个任务。这种处理问题的方式叫作同步。  
  
#### 同步任务  
1. 声明语句  
2. for循环  
3. 赋值  
* 读取后依据从上到下从左到右，立即执行  
  
#### 异步任务  
1. ajax请求  
2. setTimeout定时器  
* 异步任务会通过事件任务队列(Event Queue)机制（先进先出的队列机制）来进行协调执行  
* 异步任务不进入JS单线程，而是放在任务队列中。若有多个异步任务，也是需要在任务队列中排队等待的。  
  
#### Event Loop的基础：宏任务 & 微任务
* 异步任务，各个任务执行时间长短也差别很大。有的是 setTimeout 这种耗时很久的，有的是 promise 这种耗时较短的。  
* 当异步任务很多的时候，耗时久的就会阻塞后面所有的异步任务，包括一些很快可以执行完的也被阻塞。  
* 于是 JS 引擎就将异步任务分类管理，划分成两个队列：宏任务队列 和 微任务队列。 
  
#### 宏任务（macroTask）
1. script标签设置async 标签中的运行代码（异步任务）
2. 2种定时器setInterval,setTimeout 
3. 事件触发的回调函数:ajax、UI交互、I/O、DOM Events  
  
#### 微任务（microTask）  
1. promise的一些回调函数：.then、.catch、.finally  
2. MutationObserver( 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动)  
3. process.nextTick(node独有)-你希望异步任务尽可能快地执行，那就使用process.nextTick。（process.nextTick(callback[, ...args])）  
  
#### Event Loop的原理：宏任务与微任务交替执行  
1. 将 document 下 script 标签中的所有同步代码都放入执行栈，立即执行  
2. 执行过程中如果产出新的宏任务/微任务，就将他们推入相应的任务队列  
3. 等执行栈没有代码可以执行之后再执行微任务队列  
4. 微任务队列都执行完以后，又开始执行宏任务队列（注意点，当宏任务执行过程中，产生新的微任务，执行当前宏任务->执行所有的微任务队列->宏任务队列）  
  
