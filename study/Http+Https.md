#### HTTP协议  
- HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，
- HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范
- HTTP 主要内容分为三部分，超文本（Hypertext-传输图片、音频、视频，甚至点击文字或图片）、传输（Transfer）、协议（Protocol）。
  
#### TCP/IP网络模型（5层）  
* 应用层（第五层-HTTP,FTP,DNS,SMTP） 
* SSL (https时存在) 
* 运输层（第四层-TCP,UDP）
* 网络层（第三层-IP,ARP）
* 链路层（第二层-MAC）
* 物理层（第一层）  
  
#### HTTPS协议  
- HTTPS 的全称是 Hypertext Transfer Protocol Secure（安全）
- HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。
- 处在传输层和应用层之间的SSL  
  
#### HTTP是无状态协议  
- 无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力
- 浏览器记忆起作用的是cookie（存储sessionId），或者服务器端的JWT生成的token（与cookie相比支持跨域）  
  
#### TCP/UDP协议比较  
- TCP 是面向连接的协议（UDP 是无连接的协议）  
- TCP 在发送数据前先需要建立连接，然后再发送数据（UDP 无需建立连接就可以直接发送大量数据）  
- TCP 会按照特定顺序重新排列数据包（UDP 数据包没有固定顺序，所有数据包都相互独立）
- TCP 传输的速度比较慢（UDP 的传输会更快）  
- TCP 是可靠的，因为它可以确保将数据传送到路由器。（在 UDP 中不能保证将数据传送到目标。）
- TCP 会进行错误校验，并能够进行错误恢复（UDP 也会错误检查，但会丢弃错误的数据包。）  
  
#### TCP三次握手/四次挥手概念名词  
- SYN：这个消息是用来初始化和建立连接的。
- ACK：帮助对方确认收到的 SYN 消息
- SYN-ACK：本地的 SYN 消息和较早的 ACK 数据包
- FIN：用来断开连接
  
#### TCP三次握手（用来初始化和建立连接）  
-  SYN：它的全称是 Synchronize Sequence Numbers，同步序列编号。是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立 TCP 连接时,客户端发起连接请求,发送客户端的SYN（一种很小的数据包，SYN攻击会包含很多这种数据包）和初始化序列号seq(生成序列号：假设 X)
-  SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK-seq（SYN + ACK + seq） 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y（SYN + ACK（X+1）+seq(Y) 。  
-  ACK：Acknowledge character, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1（ACK （Y+1））。
  
1. client(SYN：数据包 + seq：假设为X序列号)--->server  （SYN数据包,ACK报文,Seq序列号）
2. server(SYN + ACK：X+1 + seq：Y)--->client
3. clinet(ACK：Y+1)--->server  
- 第一次握手（客户端发送正常）第二次握手（服务端接收正常，服务端发送正常）第三次握手（客户端接收正常）
  
#### SYN攻击（半连接队列和全连接队列）  
- 半连接队列就是说服务端第一次收到客户端的SYN后，处于SYN_RCVD状态,但服务端发送出去的 SYN + ACK 报文，无法得到未知 IP 主机的 ACK 应答,此时双方还没有完全建立起连接，服务端会把这种状态下的请求连接放到一个特定的队列里，也就是半连接队列  
- SYN攻击：不完成后续的握手过程，从而占用服务器资源  
  
#### SYN攻击解决方法  
1. 设置半连接队列的长度，可以一定程度上减轻 SYN 攻击对服务器的影响，因为半连接队列容量有限，攻击者无法无限制地占用队列空间。  
2. 当SYN半连接队列占满，计算一个cookie,设置由Seq返回客户端
  
#### TCP四次挥手（断开连接）
- 首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 FIN_WAIT_1 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应  
- 然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。  
- 当客户端收到服务器发送的 ACK 响应后，客户端就进入 FIN_WAIT_2 状态，然后等待来自服务器的 FIN 消息  
- 服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。  
- 当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 TIME_WAIT 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。  
  
1. client(ACK：Y+1 + seq：假设为X+2 + FIN：终止位)--->server  client(变为 FIN_WAIT_1)
2. server(ACK：X+3)-->client client     client(变为 FIN_WAIT_2)
3. server(seq：Y+2 + FIN)--->client     client(变为 TIME_WAIT)
4. client(ACK：Y+3)--->server client在TIME_WAIT的情况下,释放资源后关闭
  
#### 中间人攻击  
- HTTP 协议以明文传输数据，中间人拦截数据包之后能轻易的还原 HTTP 包文的内容，这使得中间人能监听 HTTP 通信的数据。  
- 使用 HTTP 协议的请求和响应方不验证对方的身份。因此请求方无法确保发起的请求由预计的响应方接受，它收到的数据也不能确保来自预计的响应方；  
- 无法验证数据的完整性。因此数据在传输过程中被篡改了，通信双方都无法知晓。  
  
#### TLS的四次握手（TLS是使用非对称加密和对称加密相结合来保证传输安全）  


  

